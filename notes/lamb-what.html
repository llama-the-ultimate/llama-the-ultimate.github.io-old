<!DOCTYPE HTML>
<html><head><meta charset="UTF-8"><title>What do the lambdas?</title><link rel="stylesheet" href="../styles.css"/></meta></head><body onresize="refreshEditors()"><div class="content"><div class="navinfo"><div class="nav"><a class="navlink" href="../index.html"><div class="navlink">λ</div></a></div></div><div class="text"><h1>What do the lambdas?</h1><p>A <span class="codew">exp</span>ression is one of the following:</p><ul><li><span class="code">&lt;identifier&gt;</span>
(variable reference)</li><li><span class="code">λ&lt;identifier&gt;.&lt;exp&gt;</span>
(function abstraction, but sometimes we’ll just call it a “lambda”)</li><li><span class="code">&lt;exp&gt; &lt;exp&gt;</span>
(function application)</li></ul><p>Is like tree. Variable references are leaves.
Function application branches into two sub-trees, one for function and one for argument.</p><p>Function application is left associative. So <span class="code">a b c</span> and <span class="code">(a b) c</span> works out the same.</p><p>For example, can take a look at expression <span class="code">(λa.a (foo a)) bar</span> and its sub-expressions:</p><ul><li><span class="code">(λa.a (foo a)) bar</span> is a function application with a function <span class="code">(λa.a (foo a))</span> and an argument <span class="codew">bar</span></li><li><span class="code">λa.a (foo a)</span> is a function abstraction with a parameter <span class="codew">x</span> and a body <span class="code">a (foo a)</span>.</li><li><span class="code">a (foo a)</span> is a function application with a function <span class="codew">a</span> and argument <span class="code">foo a</span></li><li><span class="code">foo a</span> is a function application with a function <span class="codew">foo</span> and argument <span class="codew">a</span></li></ul><p>(So really, syntax is mostly like in a ML family language or a Haskell or something.
Only instead of like, <span class="code">fn x =&gt; foo</span> or <span class="code">fun x -&gt; foo</span> or <span class="code">\x -&gt; foo</span>),
we do <span class="code">λx.foo</span>.)</p><hr/><p>Evaluation goes mostly like so: <span class="code">(λ<strong>x</strong>.<strong>B</strong>) <strong>A</strong> ⟶ [<strong>A</strong>/<strong>x</strong>]<strong>B</strong></span>.</p><p>Meaning something like, a “reducible expression” (the bit to the left of the arrow) is:</p><ul><li>a function application</li><li>with a function-part that is a function abstraction, with some identifier <span class="codew"><strong>x</strong></span> as its parameter
and some expression <span class="codew"><strong>B</strong></span> as its body</li><li>and with an argument-part that is some expression <span class="codew"><strong>A</strong></span></li></ul><p>And if we have a reducible expression, then we can do “beta reduction”: Substitute the argument <span class="codew"><strong>A</strong></span> for every free occurence of the parameter <span class="codew"><strong>x</strong></span> in the body <span class="codew"><strong>B</strong></span>,
and replace the whole function application with the result of that.</p><p>(The part that goes <span class="code">[<strong>A</strong>/<strong>x</strong>]<strong>B</strong></span> means that substitution thing: <span class="codew"><strong>B</strong></span> but with every free <span class="codew"><strong>x</strong></span> replaced with <span class="codew"><strong>A</strong></span>.
So <span class="code">(λ<strong>x</strong>.<strong>B</strong>) <strong>A</strong> ⟶ [<strong>A</strong>/<strong>x</strong>]<strong>B</strong></span> is a bit like a pattern match on the syntax of an expression.
Like, the expression to the left of the arrow binds the variables <span class="codew"><strong>x</strong></span> and <span class="codew"><strong>B</strong></span> and <span class="codew"><strong>A</strong></span>, and the expression to the right uses them.)</p><p>Can try.
With the expression <span class="code">(λz.z bar) foo</span>, the parameter <span class="codew"><strong>x</strong></span> is <span class="codew">z</span>,
the body <span class="codew"><strong>B</strong></span> is <span class="code">z bar</span>, and the argument <span class="codew"><strong>A</strong></span> is <span class="codew">foo</span>.
So for this “instance” of <span class="code">(λ<strong>x</strong>.<strong>B</strong>) <strong>A</strong> ⟶ [<strong>A</strong>/<strong>x</strong>]<strong>B</strong></span>
we get <span class="code">(λz.z bar) foo ⟶ [foo/z]z bar</span>.
It should evaluate to the body <span class="code">z bar</span>
with every free <span class="codew">z</span> replaced by the argument <span class="codew">foo</span>: <span class="code">foo bar</span>.
(<span class="code">ctrl+enter</span> below)</p><div class="editor" name="lambs" style="height:3rem">(λz.z bar) foo</div><p>A variable reference is free if it is not bound by a parameter in a function abstraction.
With the expression <span class="code">(λz.z (λz.bar z) bar) foo</span>, the parameter <span class="codew"><strong>x</strong></span> is <span class="codew">z</span>,
the body <span class="codew"><strong>B</strong></span> is <span class="code">z (λz.bar z) bar</span>, and the argument <span class="codew"><strong>A</strong></span> is <span class="codew">foo</span>.
Here, only the first z in the body <span class="code">z (λz.bar z) bar</span> is free, so only that one is replaced with <span class="codew">foo</span>.</p><div class="editor" name="lambs" style="height:3rem">(λz.z (λz.bar z) bar) foo</div><p>(In maybe more programmy jargon, we could maybe say that the inner <span class="codew">z</span> shadows the outer.)</p><p>Sometimes we have to change the names of some variables before doing beta reduction,
in order to avoid having “variable capture” change the meaning of our expression.
With the expression <span class="code">(λx.λy.y x) y</span>, the parameter <span class="codew"><strong>x</strong></span> is <span class="codew">x</span>,
the body <span class="codew"><strong>B</strong></span> is <span class="code">λy.y x</span>, and the argument <span class="codew"><strong>A</strong></span> is <span class="codew">y</span>.
If we just replace the <span class="codew">x</span> in <span class="code">λy.y x</span> with <span class="codew">y</span>, we get <span class="code">λy.y y</span>.
Our argument-<span class="codew">y</span> becomes like bound (“captured”) by the parameter of the lambda within the body.
Is no good. We should be able to keep refering to some outer <span class="codew">y</span>.
So, we change the name of the parameter of the lambda (and all references to it) before we do beta reduction.
(<span class="code">ctrl+enter</span> two times, since the first one will just rename the parameter)</p><div class="editor" name="lambs" style="height:3rem">(λx.λy.y x) y</div><hr/><p>That’s mostly it.
We:</p><ol><li>look through our expression-tree in some order</li><li>maybe find a reducible expression</li><li>rename things if necessary</li><li>and do the substitution thing</li></ol><p>The order we look through the expression-tree is “normal order”.
We check the outermost expression first, and then the function-parts of applications before the argument-parts.
If we can’t find any reducible expression, then the expression is on “normal form”.</p><p>Typically we want to evaluate something down to normal form.
So we run through those steps over and over until it is.
(If we’re unlucky that takes actually forever. But that’s cool too.)</p><p>Can do (<span class="code">ctrl+shift+enter</span>) to evaluate the foillowing until it’s on normal form:</p><div class="editor" name="lambs" style="height:6rem">(λz.z foo) (λx.λy.x bar y) quux</div></div></div><script data-main="../lambstuff/reqmain" src="../lambstuff/require.js"></script><script src="../lambstuff/monaco-editor/min/vs/loader.js"></script><script src="../lambstuff/stuff.js"></script></body></html>