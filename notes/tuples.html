<!DOCTYPE HTML>
<html><head><meta charset="UTF-8"><title>I like tuples</title><link rel="stylesheet" href="../styles.css"/></meta></head><body><div class="content"><div class="navinfo"><div class="nav"><a class="navlink" href="../index.html"><div class="navlink">λ</div></a></div></div><div class="text"><h1>I like tuples</h1><div class="date">(????-??-??)</div><p>In a language where a function is a thing that takes one value as argument and returns one value as result, we tend to need <em>stuff</em> when we want to make a function that “takes multiple arguments.”
One way of going about it is to use a tuple to group several values into like one large value, and then pass that value to our function.
Another way is to do like currying, and make a function that takes the first argument and returns a function that takes the second argument and so on. Woop woop.</p><p>In Standard ML we can do the tuples thing like so:</p><pre>- fun foo (a, b, c) = a + b + c;
val foo = fn : int * int * int -&gt; int</pre><p>Or curried thing like so:</p><pre>- fun bar a b c = a + b + c;
val bar = fn : int -&gt; int -&gt; int -&gt; int</pre><p>Bla bla bla. Anyway. Few things I kind of like about tuples:</p><p>(I think they’re all the same ting really. And that that thing is that a tuple is a value.)</p><hr/><p>We can tuple together multiple return-values much like we can tuple together multiple argument-values. It works rather directly the same way.</p><pre>- fun triple a = (a, a, a);
val triple = fn : 'a -&gt; 'a * 'a * 'a</pre><p>(I’m not certain what would be the more “currying-like” way to deal with return-values. Maybe returning Church-encoded tuples I dunno.)</p><p>If we have some function that we don’t know a ton of stuff about, like maybe one we took as an argument or something, then it’s maybe easier to not care about how many arguments <em>it</em> takes.
If there are multiple, they’re going to be all tupled up into just one value anyway, and we won’t have to do stuff like passing one argument to the function and another one to the function that is returned.
Things like composing things seems to work out less awkwardly at times:</p><pre>- Int.toString o foo o triple;
val it = fn : int -&gt; string</pre><p>(If we tried to do the same, but with <span class="codew">bar</span> instead of <span class="codew">foo</span>, the compose-function, <span class="codew">o</span>, would pretty unable to pass the result of <span class="codew">triple</span> into <span class="codew">bar</span>, or the result of <span class="codew">bar</span> into <span class="codew">Int.toString</span>. Since <span class="codew">bar</span> returns an <span class="code">int -&gt; int -&gt; int</span> rather than just an <span class="codew">int</span>, and so on.)</p><hr/><p>Seems like it’s more straightforward to do like a decent error message for “wrong number of arguments” to a function if they’re in an argument-tuple.</p><p><span class="code">foo (1, 2)</span> gives some error message about how <span class="code">int * int</span> doesn’t match up with <span class="code">int * int * int</span>.</p><p><span class="code">bar 1 2</span> seems to work fine, but we’re left with an <span class="code">int -&gt; int</span> instead of just an <span class="codew">int</span>. Typically leads to error sometime elsewhere.</p></div></div></body></html>