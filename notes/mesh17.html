<!DOCTYPE HTML>
<html><head><meta charset="UTF-8"><title>Code Mesh and infinite llamas</title><link rel="stylesheet" href="../styles.css"/></meta></head><body><div class="content"><div class="navinfo"><div class="nav"><a class="navlink" href="../index.html"><div class="navlink">λ</div></a></div></div><div class="text"><h1>Code Mesh and infinite llamas</h1><p>Possibly a bit of a companion post for the Code Mesh talk <a href="http://www.codemesh.io/codemesh2017/jonas-winje">Infinite Lambda Calculus</a>.</p><p>Importantliest: The code used, along with some instructions, <a href="https://github.com/Glorp/lambs/tree/mesh17">is on GitHub</a>.
The, uh, file we ended up with in the talk <a href="https://github.com/Glorp/lambs/blob/mesh17/lambs/mesh.txt">also is</a>.
It is what it is.</p><p>(Also, there are some related lambdas like, nearby.
It is possible to take a look over <a href="../lists/lambs.html">here</a>,
or just like play with stuff over <a href="../lambdas.html">there</a>.)</p><hr/><p>Maybe the talk has a main point or something.
It goes possibly like this:</p><ul><li>We wanna get something like infinite, or at least pretty infinite, loops.</li><li>Lambda calculus is Turing complete, but it kind of wasn’t supposed to be?</li><li>Turing complete things can probably do infinite loops,</li><li>Type systems tend to get rid of like accidental Turing completeness.</li></ul><p>We can come up with a recipe for making a loopy thing:</p><ol><li>Look for a tiny expression that wouldn’t typecheck if we had a type system-and-checker.
(If the type system doesn’t like an expression, then maybe that expression leads to Turing completeness and infinite loops?)</li><li>Type checkers sure don’t much like <span class="code">λx.x x</span>.</li><li><span class="code">(λx.x x) (λx.x x)</span> goes on and on. For maybe forever?</li><li>Adding e.g. <span class="codew">foo</span> like so: <span class="code">(λx.x x) (λx.foo (x x))</span> will give us (more than) as many <span class="codew">foo</span>s as we want.
Doing a few steps of evaluation will get us <span class="codew">foo (foo ((λx.foo (x x)) (λx.foo (x x))))</span>.
If we do more steps we get more <span class="codew">foo</span>s.</li><li>We can do this with like any <span class="codew">f</span>, instead of just with <span class="codew">foo</span>, because lambda abstraction:
<span class="codew">λf.(λx.x x) (λx.f (x x))</span>.</li><li>One step of evaluation takes <span class="codew">λf.(λx.x x) (λx.f (x x))</span> to <span class="codew">λf.(λx.f (x x)) (λx.f (x x))</span>.</li></ol><p><span class="codew">λf.(λx.f (x x)) (λx.f (x x))</span> is the Y combinator :)</p></div></div></body></html>