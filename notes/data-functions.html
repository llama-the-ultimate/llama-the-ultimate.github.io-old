<!DOCTYPE HTML>
<html><head><meta charset="UTF-8"><title>Data with functions on top</title><link rel="stylesheet" href="../styles.css"/></meta></head><body><div class="content"><h1>Data with functions on top</h1><div class="belowtitle">(<a class="homelink" href="../index.html">Index.</a>)</div><p><a href="https://mitpress.mit.edu/books/little-mler">The Little MLer</a> is a pretty fun book.
There’s a lot of Standard ML code in it and Standard ML code has a lot of <span class="codew">fun</span> in it.</p><p>Anyway there’s this theme in the book. We define a bunch of datatypes, and we define functions on them.
And as the datatypes become more complicated and sophisticated, then, kind of “naturally,” so do the functions.</p><p>Like, we can introduce a recursive type, like one for natural numbers:</p><pre>datatype natural =
    Zero
  | Succ of natural</pre><p>And then when we wanna do stuff with the numbers, we kind of necessarily get recursive functions, like:</p><pre>fun add (a, b) =
    case a of
        Zero =&gt; b
      | Succ x =&gt; Succ (add (x, b))</pre><p>(And so:</p><pre>- add (Succ (Succ Zero), Succ Zero);
val it = Succ (Succ (Succ Zero)) : natural</pre><p>Woop woop.)</p><p>Stuff like that. A type with more constructors typically leads to pattern matching with more patterns. Mutually recursive types lead to mutually recursive functions. …</p><hr/><p>(Which is totes a thing also expressed elsewhere. It’s sometimes approached from the opposite direction. Always with less whim.)</p><p>(On the more type theoretic/beautiful side, it is not too far away from the idea of types being defined by their introduction and elimination rules, and the computational building blocks of a language being those rules.
Every bit of behaviour being constructing and destructing of values.)</p><hr/><p>So, uh. Software Engineering! I think a pretty common thing is that things start falling apart when we have like very sophisticated behaviour, built on top of not so sophisticated data structures.</p></div></body></html>